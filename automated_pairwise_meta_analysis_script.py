# -*- coding: utf-8 -*-
"""Automated Pairwise Meta-Analysis Script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iNdr4Jgs2-VXkA0w7nIO6ojeUj7Nyjqx
"""

# --- Section 1: Setup ---------------------------------------------------------
# First, we'll make sure all the necessary tools (R packages) are ready.
# We use 'pacman' to easily load or install packages if they're missing.

if (!require("pacman")) install.packages("pacman")
pacman::p_load(
    meta,       # The core package for meta-analysis
    metafor,    # Used for meta-regression and other advanced methods
    readr,      # For reading CSV files quickly and reliably
    dplyr,      # For intuitive data manipulation (filtering, selecting, etc.)
    stringr,    # For working with text and column names
    tools,      # For file path tools like file_ext()
    IRdisplay   # To display plots directly in the notebook
)


# --- Section 2: Helper Functions -----------------------------------------
# These are our "assistant" functions that handle specific, repeatable tasks,
# like finding outcomes in the data or asking the user to make a choice.

#' Find Potential Outcomes in the Data
#'
#' This function cleverly scans the column names of your dataset to find
#' what look like outcome variables. It searches for common patterns like
#' "_mean.e", "_sd.c", ".event.e", etc.
#'
#' @param data A data frame containing your meta-analysis data.
#' @return A character vector of unique outcome prefixes (e.g., "FunctionalScore").
find_possible_outcomes <- function(data) {
    column_names <- names(data)

    # Regex to find columns ending in ".e" or ".c" (for experimental/control)
    # and remove common suffixes like "_mean", "_sd", etc. to get the base name.
    prefixes <- column_names %>%
        str_extract(".*(?=\\.(e|c)$)") %>%
        str_remove("[._](mean|sd|n|event)$") %>%
        unique() %>%
        na.omit() # Remove any names that didn't match

    return(prefixes)
}


#' Ask the User to Select an Outcome
#'
#' Displays a numbered list of the outcomes found in the data and prompts
#' the user to choose one for the analysis.
#'
#' @param data A data frame containing your meta-analysis data.
#' @return The selected outcome prefix as a string.
ask_for_outcome <- function(data) {
    available_outcomes <- find_possible_outcomes(data)

    if (length(available_outcomes) == 0) {
        stop("Sorry, I couldn't detect any outcomes. Please make sure your columns are named correctly (e.g., 'outcome_mean.e', 'outcome.event.c').")
    }

    cat("Here are the outcomes I found in your data:\n")
    for (i in seq_along(available_outcomes)) {
        cat(sprintf("%d: %s\n", i, available_outcomes[i]))
    }

    flush.console()
    choice_num <- as.integer(readline("\nPlease select an outcome by typing its number: "))

    if (is.na(choice_num) || choice_num < 1 || choice_num > length(available_outcomes)) {
        stop("That's not a valid selection. Please run the script again and choose a number from the list.")
    }

    return(available_outcomes[choice_num])
}


#' Ask the User to Select an Effect Size Metric
#'
#' Presents a list of common effect size metrics and asks the user to pick one.
#'
#' @return The selected effect size metric as a string (e.g., "MD", "SMD").
ask_for_effect_size <- function() {
    cat("\nWhich effect size metric should we use?\n")
    cat("  1: MD (Mean Difference) - for continuous data\n")
    cat("  2: SMD (Standardized Mean Difference) - for continuous data\n")
    cat("  3: OR (Odds Ratio) - for binary data\n")
    cat("  4: RR (Risk Ratio) - for binary data\n")

    flush.console()
    choice_num <- as.integer(readline("\nEnter your choice (1-4): "))

    metrics <- c("MD", "SMD", "OR", "RR")

    if (is.na(choice_num) || !choice_num %in% 1:4) {
        stop("Invalid selection. Please run the script again and choose a number from 1 to 4.")
    }

    return(metrics[choice_num])
}


#' Ask the User to Select a Subgroup Column
#'
#' Identifies columns that could be used for subgrouping and lets the user
#' choose one, or skip this step.
#'
#' @param data A data frame containing your meta-analysis data.
#' @return The selected subgroup column name as a string, or NULL if skipped.
ask_for_subgroup_column <- function(data) {
    all_column_names <- names(data)

    # Potential subgroup columns are those that are NOT the author column or data columns.
    data_pattern <- "[._](mean|sd|n|event)\\.(e|c)$"
    subgroup_candidates <- all_column_names[!grepl(data_pattern, all_column_names) & all_column_names != "Author"]

    if (length(subgroup_candidates) == 0) {
        cat("\nNo potential columns found for subgroup analysis.\n")
        return(NULL)
    }

    cat("\nAvailable columns for subgroup analysis:\n")
    for (i in seq_along(subgroup_candidates)) {
        cat(sprintf("  %d: %s\n", i, subgroup_candidates[i]))
    }

    flush.console()
    choice_input <- readline("Select a column by number (or just press Enter to skip): ")

    if (choice_input == "") {
        cat("Skipping subgroup analysis.\n")
        return(NULL)
    }

    choice_num <- as.integer(choice_input)

    if (is.na(choice_num) || choice_num < 1 || choice_num > length(subgroup_candidates)) {
        warning("That's not a valid choice. Proceeding without subgroup analysis.")
        return(NULL)
    }

    return(subgroup_candidates[choice_num])
}


# --- Section 3: The Main Event - Running the Analysis ---------

# --- 3.1: Welcome and File Input ---
cat("Welcome to the Automated Meta-Analysis Script!\n")
file_path <- readline(prompt = "Please enter the full path to your meta-analysis CSV file: ")

if (!file.exists(file_path) || tolower(file_ext(file_path)) != "csv") {
    stop("File not found or it is not a CSV. Please check the path and try again.")
}
full_meta_data <- read_csv(file_path, show_col_types = FALSE)


# --- 3.2: Gathering Analysis Choices & Labels ---
cat("\n--- Analysis Configuration ---\n")
outcome_prefix <- ask_for_outcome(full_meta_data)
effect_size_metric <- ask_for_effect_size()

cat("\nNow, let's add some descriptive labels for your plots.\n")
outcome_label <- readline(prompt = "Enter a name for the outcome (e.g., 'Functional Improvement Score'): ")
experimental_label <- readline(prompt = "Enter a label for the experimental group (e.g., 'New Treatment'): ")
control_label <- readline(prompt = "Enter a label for the control group (e.g., 'Standard Care'): ")

model_choice_input <- readline(prompt = "\nWhich model do you want to use? (fixed/random): ")
model_choice <- tolower(model_choice_input)
if (!model_choice %in% c("fixed", "random")) {
    warning("Invalid model choice. Defaulting to the 'random' effects model.")
    model_choice <- "random"
}


# --- 3.3: Preparing the Data ---
# We'll filter the dataset to include only the studies that have complete
# data for the chosen outcome. This is a crucial step to prevent errors.
cat("\nFiltering data to include only complete studies for this outcome...\n")

# Determine the required columns based on the chosen effect size
if (effect_size_metric %in% c("MD", "SMD")) {
    required_columns <- c(
        paste0(outcome_prefix, "_mean.e"), paste0(outcome_prefix, "_sd.e"), paste0(outcome_prefix, ".n.e"),
        paste0(outcome_prefix, "_mean.c"), paste0(outcome_prefix, "_sd.c"), paste0(outcome_prefix, ".n.c")
    )
} else { # For "OR", "RR"
    required_columns <- c(
        paste0(outcome_prefix, ".event.e"), paste0(outcome_prefix, ".n.e"),
        paste0(outcome_prefix, ".event.c"), paste0(outcome_prefix, ".n.c")
    )
}

# Filter the data using dplyr pipes for readability
analysis_data <- full_meta_data %>%
    # Keep rows where all required columns have data
    filter(if_all(all_of(required_columns), ~ !is.na(.)))

# Also filter out rows with zero or negative sample sizes, which are invalid
if (effect_size_metric %in% c("MD", "SMD")) {
    analysis_data <- analysis_data %>%
        filter(.data[[required_columns[3]]] > 0 & .data[[required_columns[6]]] > 0)
} else {
    analysis_data <- analysis_data %>%
        filter(.data[[required_columns[2]]] > 0 & .data[[required_columns[4]]] > 0)
}

cat(nrow(analysis_data), "studies have complete data and will be included in the analysis.\n")


# --- 3.4: Optional Subgroup Analysis ---
subgroup_column <- NULL
run_subgroup_choice <- readline(prompt = "\nDo you want to perform a subgroup analysis? (yes/no): ")
if (tolower(run_subgroup_choice) == "yes") {
    subgroup_column <- ask_for_subgroup_column(analysis_data)
    if (!is.null(subgroup_column)) {
        cat("Great! Subgroup analysis will be performed on the '", subgroup_column, "' column.\n")
    }
}


# --- 3.5: Running the Meta-Analysis ---
cat("\nRunning the meta-analysis...\n")

# We'll use a list to hold all the arguments for the meta-analysis function.
# This makes the code cleaner and easier to manage.
analysis_parameters <- list(
    studlab = analysis_data$Author,
    label.e = experimental_label,
    label.c = control_label,
    common = (model_choice == "fixed"),
    random = (model_choice == "random")
)

# Add specific parameters based on user choices
if (model_choice == "random") {
    analysis_parameters$method.random.ci <- "HK" # Hartung-Knapp adjustment
}

if (!is.null(subgroup_column)) {
    analysis_parameters$subgroup <- analysis_data[[subgroup_column]]
}

# Prepare arguments for either continuous or binary data
if (effect_size_metric %in% c("MD", "SMD")) {
    meta_function <- "metacont"
    analysis_parameters$sm <- effect_size_metric
    analysis_parameters$mean.e <- analysis_data[[required_columns[1]]]
    analysis_parameters$sd.e <- analysis_data[[required_columns[2]]]
    analysis_parameters$n.e <- analysis_data[[required_columns[3]]]
    analysis_parameters$mean.c <- analysis_data[[required_columns[4]]]
    analysis_parameters$sd.c <- analysis_data[[required_columns[5]]]
    analysis_parameters$n.c <- analysis_data[[required_columns[6]]]
} else { # For "OR", "RR"
    meta_function <- "metabin"
    analysis_parameters$sm <- effect_size_metric
    analysis_parameters$event.e <- analysis_data[[required_columns[1]]]
    analysis_parameters$n.e <- analysis_data[[required_columns[2]]]
    analysis_parameters$event.c <- analysis_data[[required_columns[3]]]
    analysis_parameters$n.c <- analysis_data[[required_columns[4]]]
}

# Execute the meta-analysis function with our prepared arguments
meta_results <- do.call(meta_function, analysis_parameters)
print(summary(meta_results))


# --- Section 4: Visualizations and Further Analysis -----------------------
cat("\n--- Generating Plots and Analysis ---\n")

# --- 4.1: Forest Plot ---
cat("Generating Forest Plot...\n")
forest_plot_file <- "forest_plot.png"
png(forest_plot_file, width = 2000, height = 600 + meta_results$k * 80, res = 150)
forest(meta_results,
       main = paste("Forest Plot -", outcome_label),
       leftlab = experimental_label,
       rightlab = control_label)
dev.off()
display_png(file = forest_plot_file)


# --- 4.2: Funnel Plot ---
cat("Generating Funnel Plot to check for publication bias...\n")
funnel_plot_file <- "funnel_plot.png"
png(funnel_plot_file, width = 1200, height = 1000, res = 150)
funnel(meta_results, main = paste("Funnel Plot -", outcome_label))
dev.off()
display_png(file = funnel_plot_file)


# --- 4.3: Sensitivity Analysis (Leave-One-Out) ---
cat("\nRunning a 'leave-one-out' sensitivity analysis...\n")
meta_influence_results <- metainf(meta_results, random = (model_choice == "random"))
print(meta_influence_results)

sensitivity_plot_file <- "sensitivity_plot.png"
png(sensitivity_plot_file, width = 2000, height = 600 + meta_results$k * 80, res = 150)
forest(meta_influence_results, main = paste("Leave-One-Out Sensitivity Analysis -", outcome_label))
dev.off()
display_png(file = sensitivity_plot_file)


# --- 4.4: Meta-Regression (Optional) ---
run_meta_regression_choice <- readline(prompt = "\nDo you want to run a meta-regression? (yes/no): ")
if (tolower(run_meta_regression_choice) == "yes") {
    cat("\n--- Meta-Regression ---\n")

    cat("Available columns for meta-regression:\n")
    print(names(analysis_data))

    moderator_input <- readline("Enter one or more moderator variable names, separated by commas (e.g., year, dosage): ")
    moderators <- trimws(strsplit(moderator_input, ",")[[1]])

    for (mod in moderators) {
        if (mod %in% names(analysis_data)) {
            # Using the rma() function from the 'metafor' package for regression
            regression_formula <- as.formula(paste("~", mod))
            regression_results <- rma(yi = meta_results$TE, sei = meta_results$seTE, mods = regression_formula, data = analysis_data)

            cat("\n--- Meta-Regression Results for Moderator:", mod, "---\n")
            print(summary(regression_results))
        } else {
            cat("\nWarning: Moderator '", mod, "' not found in the data. Skipping.\n")
        }
    }
}

cat("\n--- Script Finished ---\n")